{
  "beforeRunningCommand": "nop",
  "bundleUUID": "4675A940-6227-11D9-BFB1-000D93589AF6",
  "command": "#!/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby\nline = STDIN.read\n$tab = (ENV['TM_SOFT_TABS'] == \"NO\" ? \"\\t\" : \" \"*ENV['TM_TAB_SIZE'].to_i )\ndef join_code s\n  # transform // comments to /* */ comments while leaving strings intact\n  s.gsub!(/((['\"])(?:\\\\.|.)*?\\2)|\\/\\*.*?\\*\\/|\\/\\/([^\\n\\r]*)/m) do |line| \n      if $3\n        '/*' + $3.gsub(/\\*\\//, '') + '*/'\n      else\n        line\n      end\n    end\n  print s.split(\"\\n\").map {|line| line.strip}.join(\" \")\nend\n\ndef print_line(line, indent, for_ticker)\n  s = \"\"\n  s = \"\\n\" if for_ticker == 0\n  s + $tab*indent + line # the space should be replaced with soft or hard tab\nend\n\ndef split_code s\n  res = []\n  indent = 0\n  for_ticker = 1\n  # this regexp should not have a capture depth deeper than 1\n  # yes that does rule out backrefs :(\n  s.split(/([\\{\\}\\;]|\"(?:\\\\.|.)*?\"|'(?:\\\\.|.)*?'|\\/\\*.*?\\*\\/|\\/\\/[^\\n\\r]*)/).map do |l|\n    l = l.strip\n    case l\n    when /^for\\s*\\(/\n      res << print_line(l, indent, for_ticker)\n      for_ticker = 5\n    when \"{\"\n      s = print_line(l, indent, for_ticker)\n\t for_ticker -= 1 unless for_ticker == 0\n      indent += 1\n\t  s += print_line(\"\", indent, for_ticker)\n      res << s\n    when \"}\"\n      indent -= 1\n      res << print_line(l, indent, for_ticker)\n      res << print_line(\"\", indent, for_ticker)\n    when \";\"\n      res << l\n      if for_ticker == 0\n        res << print_line(\"\", indent, for_ticker)\n      else\n        res << \" \"\n      end\n    when /^\\s*$/\n\t for_ticker += 1 # if empty string maintain the status-quo\n    else\n      res << l\n    end\n    for_ticker -= 1 unless for_ticker == 0\n  end\n\nrequire \"enumerator\"\nout = []\nres.each_cons(2) do |a,b|\n   # remove empty lines inserted when ; is followed by { or }\n\tout << a unless a.match(/^\\n\\s*$/) && b.match(/^\\n\\s*(\\}|\\{)\\s*$/)\nend\nprint out.join\nend\n\nif line.count(\"\\n\") > 1\n\tjoin_code(line)\nelse\n\tsplit_code(line)\nend\n\n#k = \"- (id)showSomeWindow \n#  {\n#     for(int i =0;i<a;i++)\n#     {\n#       \\\" boras /* */ //\\\"\n#       // hello /* */   \n#       if(a)\n#         [ window makeKeyAndOrderFront:self];\n#       }\n#     }\"\n#join_code(k)\n#l = \"- (id)showSomeWindow { for(int i =0;i<a;i++) { \\\" boras /* */ //\\\" /* hello /*    */ if(a) [ window makeKeyAndOrderFront:self]; } }\"\n#split_code(l)",
  "fallbackInput": "scope",
  "input": "selection",
  "keyEquivalent": "^{",
  "name": "Fold/Unfold Code",
  "output": "replaceSelectedText",
  "scope": "meta.block.c"
}
