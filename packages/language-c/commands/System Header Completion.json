{
  "beforeRunningCommand": "nop",
  "command": "#!/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby -wKU\nrequire \"#{ENV['TM_SUPPORT_PATH']}/lib/escape\"\nrequire \"#{ENV['TM_SUPPORT_PATH']}/lib/exit_codes\"\n\ndef parse(input)\n  return :system, $1 if input =~ /^<(.*?)>?$/\n  return :user, $1   if input =~ /^\"(.*?)\"?$/\n  abort \"Malformed input: #{input}\"\nend\n\ndef wrap(header, domain)\n  return \"<#{header}>\"   if domain == :system\n  return \"\\\"#{header}\\\"\" if domain == :user\n  abort \"Unknown domain: #{domain}\"\nend\n\ndomain, input = parse(STDIN.read)\nstring        = %x{ \"$TM_BUNDLE_SUPPORT/bin/headers\" -p #{e_sh input} -d #{domain} -C \"${TM_DIRECTORY}\" }\nlist          = string.split(\"\\n\").reject { |e| e == input }\nprefix        = list.inject { |lhs, rhs| lhs = lhs.chop while lhs != rhs[0...lhs.length]; lhs }\nlist          = list.map { |e| e_sn e[prefix.size..-1] }\n\ncase list.size\n  when 0 then TextMate.exit_show_tool_tip \"No headers matching ‘#{input}’.\"\n  when 1 then print wrap(\"#{e_sn string}$0\", domain)\n  else        print wrap(\"#{e_sn prefix}${1|#{list.join(',')}|}\", domain)\nend\n",
  "fallbackInput": "scope",
  "input": "selection",
  "inputFormat": "text",
  "keyEquivalent": "~\u001b",
  "name": "Header Completion",
  "outputCaret": "afterOutput",
  "outputFormat": "snippet",
  "outputLocation": "replaceInput",
  "scope": "meta.preprocessor.c.include string.quoted",
  "version": 2
}
