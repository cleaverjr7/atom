{
  "beforeRunningCommand": "nop",
  "command": "#!/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby -KU\n# encoding:  UTF-8\n\nrequire \"rexml/text\"\nrequire \"#{ENV[\"TM_SUPPORT_PATH\"]}/lib/escape\"\n\n# transform XML into normal and sanitized Ruby\nruby, safe_ruby, scope = \"\", \"\", []\nSTDIN.read.scan(/<(.*?)>|([^<]+)/) do\n  if $1\n    if $1[0] == ?/\n      scope.pop\n    else\n      scope.push($1)\n    end\n  else\n    unescaped =  REXML::Text.unnormalize($2)\n    ruby      << unescaped\n    # strip strings, regexes, and comments from safe_ruby but leave byte count\n    if scope.any? { |s| s =~ /\\A(?:string|comment)\\b/ }\n      safe_ruby << \" \" * unescaped.length\n    else\n      safe_ruby << unescaped\n    end\n  end\nend\n\n# find and mark the cursor\nline_number      = ENV[\"TM_LINE_NUMBER\"].to_i\ninput_start_line = ENV[\"TM_INPUT_START_LINE\"].to_i\nrow              = line_number - input_start_line\ncol              = ENV[\"TM_LINE_INDEX\"].to_i\nif line_number == input_start_line\n  col -= ENV[\"TM_INPUT_START_LINE_INDEX\"].to_i\nend\ncursor               = ruby[/\\A(?:.*\\n){#{row - 1}}.{#{col}}/].size\nCURSOR               = [0xFFFC].pack(\"U\")\nB                    = \"(?:\\\\b|#{CURSOR})\"  # Note:  /\\w/u includes CURSOR\nruby[cursor, 0]      = CURSOR\nsafe_ruby[cursor, 0] = CURSOR\n\n# find the block nearest to the cursor\nblock_start, block_length = nil, nil\nloop do\n  block_start = safe_ruby.rindex( /(\\{|#{B}do#{B})/,\n                                  block_start.nil? ? cursor : block_start - 1 )\n  if block_start.nil?  # block not found:  give up and don't change the document\n    print e_sn(ruby).sub(CURSOR, \"$0\")\n    exit\n  end\n  block_length, nesting = 0, []\n  if $1 == \"{\"\n    re, starts, stop = /\\{|\\}|[^{}]+/, [\"{\"], \"}\"\n  else\n    re, starts, stop = /#{B}do#{B}|#{B}end#{B}|./m, [\"do\"], \"end\"\n  end\n  safe_ruby[block_start..-1].scan(re) do |token|\n    block_length += token.length\n    token.sub!(/\\A#{CURSOR}/, \"\")\n    token.sub!(/#{CURSOR}\\z/, \"\")\n    case token\n    when *starts\n      nesting << token\n    when stop\n      if nesting.last.nil?\n        nesting << nil\n        break\n      else\n        nesting.pop\n        break if nesting.empty?\n      end\n    end\n  end\n  break if nesting.empty? and ruby[block_start, block_length].include? CURSOR\nend\nblock = ruby[block_start, block_length]\n\n# toggle the block\nif block[0] == ?{\n  block = block[1..-2]\n  if block.include? \"\\n\"\n    block[0, 0] =  \" \" if block =~ /\\A#{CURSOR}?[A-Za-z0-9_]/\n    block       << \" \" if block =~ /[A-Za-z0-9_]#{CURSOR}?\\z/\n    block       =  \"do#{block}end\"\n  else  # expand the block\n    block.strip!\n    lines = %w[do]\n    if block.sub!(/\\A(#{CURSOR}?(\\s*)\\|[^|]*\\|)/, \"\")\n      lines.first << \"#{' ' if $2.empty?}#{$1}\"\n    end\n    indent =  ruby[0...block_start][/^([ \\t]*).*\\Z/, 1]\n    tab    =  ( ENV[\"TM_SOFT_TABS\"] == \"YES\" ? \" \" * ENV[\"TM_TAB_SIZE\"].to_i :\n                                               \"\\t\" )\n    lines  << \"#{indent}#{tab}#{block.strip}\"\n    lines  << \"#{indent}end\"\n    block  =  lines.join(\"\\n\")\n  end\nelse\n  block = block[2..-4]\n  if block.include? \"\\n\"  # collapse the block\n    lines = block.send(block.respond_to?(:lines) ? :lines : :to_s).to_a\n    lines.first.send(\n      \"#{'r' if lines.first =~ /\\A\\s*#{CURSOR}?\\s*\\|[^|]*\\|/}strip!\"\n    )\n    lines[1..-1].each do |line|\n      line.strip!\n    end\n    lines.first << \"; \" unless lines.first =~\n                               /\\A\\s*#{CURSOR}?\\s*(?:\\|[^|]*\\|)?\\s*#{CURSOR}?\\z/\n    lines.first << \" \"  unless lines.first =~ /\\s\\z/\n    lines[1..-2].each do |line|\n      line << \"; \"\n    end\n    lines[-2].sub!(/; \\z/, \"\") if lines.size > 2 and lines.last.empty?\n    cursor_by_end = lines.size > 2 && lines.last == CURSOR\n    lines[-2].sub!(/; \\z/, \" \") if cursor_by_end\n    block = \"{#{lines.join}#{' ' unless cursor_by_end}}\"\n  else\n    block = \"{#{block}}\"\n  end\nend\n\n# replace document\nprint e_sn(ruby[0...block_start])\nprint e_sn(block).sub(CURSOR, \"$0\")\nprint e_sn(ruby[(block_start + block_length)..-1])\n",
  "input": "selection",
  "inputFormat": "xml",
  "keyEquivalent": "^{",
  "name": "Toggle ‘do … end’ / ‘{ … }’",
  "output": "insertAsSnippet",
  "scope": "source.ruby"
}
