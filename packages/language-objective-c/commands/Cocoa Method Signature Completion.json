{
  "beforeRunningCommand": "nop",
  "bundleUUID": "4679484F-6227-11D9-BFB1-000D93589AF6",
  "command": "#!/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby\nrequire ENV['TM_SUPPORT_PATH'] + \"/lib/exit_codes\"\nrequire \"#{ENV['TM_SUPPORT_PATH']}/lib/escape\"\n\nline = ENV['TM_CURRENT_LINE']\n\ndef construct_arg_name(arg)\n\ta = arg.match(/(NS|AB|CI|CD)?(Mutable)?(([AEIOQUYi])?[A-Za-z_0-9]+)/)\n\tunless a.nil?\n\t\t(a[4].nil? ? \"a\": \"an\") + a[3].sub!(/\\b\\w/) { $&.upcase }\n\telse\n\t\t\"\"\n\tend\nend\n\ndef prettify(cand, call)\n  stuff = cand.split(\"\\t\")\n  if stuff[0].count(\":\") > 0\n    name_array = stuff[0].split(\":\")\n    out = \"\"\n    begin\n      stuff[-(name_array.size)..-1].each_with_index do |arg,i|\n        if arg == \"SEL\"\n          out << name_array[i] +  \":(SEL)\"+ \"aSelector \"\n        else\n          out << name_array[i] +  \":(\"+ arg.gsub(/ \\*/,(ENV['TM_C_POINTER'] || \" *\").rstrip)+\")\"+ \"#{construct_arg_name(arg)} \"\n        end\n      end\n    rescue NoMethodError\n      out << stuff[0]\n    end\n  else\n    out = stuff[0]\n  end\n  out = \"(#{stuff[5].gsub(/ \\*/,(ENV['TM_C_POINTER'] || \" *\").rstrip)})#{out}\" unless call || (stuff.size < 4)\n\n  return [out.chomp.strip, stuff[0], cand]\nend\n\ndef snippet_generator(cand, start, call)\nstart = 0\n  stuff = cand[start..-1].split(\"\\t\")\n  if stuff[0].count(\":\") > 0\n\n    name_array = stuff[0].split(\":\")\n    name_array = [\"\"] if name_array.empty? \n    out = \"\"\n    begin\n      stuff[-(name_array.size)..-1].each_with_index do |arg,i|\n          if arg == \"SEL\"\n            out << name_array[i] + \":(#{arg})${#{(i+1).to_s}:aSelector} \" \n          else\n            out << name_array[i] + \":(#{arg.gsub(/ \\*/,(ENV['TM_C_POINTER'] || \" *\").rstrip)})${#{(i+1).to_s}:#{construct_arg_name(arg)}} \"\n          end\n      end\n    rescue NoMethodError\n      out << stuff[0]\n    end\n  else\n    out = stuff[0]\n  end\nout = \"(#{stuff[5].gsub(/ \\*/,(ENV['TM_C_POINTER'] || \" *\").rstrip)})#{out}\" unless (stuff.size < 4)\n  if ENV['TM_SCOPE'].include? \"meta.scope.implementation.objc\"\n    if stuff[5].match(/^void$/) || stuff[5].match(/IBAction/)\n      rv = \"\"\n    elsif stuff[5].match(/^BOOL$/)\n      rv = \"\\treturn ${1:Y}${1/^(?:(Y)|(N)|.*)/(?1:ES:(?2:O))/};\\n\"\n    else\n      rv = \"\\treturn nil;\\n\"\n    end\n    \n    out = out.chomp.strip + \"\\n\\{$0\\n#{rv}\\}\"\n  else\n    out = out.chomp.strip + \"$0;\"\n  end\n  return out\nend\n\ndef pop_up(candidates, searchTerm, call = true)\n  start = searchTerm.size\n  prettyCandidates = candidates.map { |candidate| prettify(candidate,call) }.sort\n\nif prettyCandidates.size > 1\n    require \"enumerator\"\n    pruneList = []  \n\n    prettyCandidates.each_cons(2) do |a| \n      pruneList << (a[0][0] != a[1][0]) # check if prettified versions are the same\n    end\n    pruneList << true\n    ind = -1\n    prettyCandidates = prettyCandidates.select do |a| #remove duplicates\n      pruneList[ind+=1]  \n    end\n  end\n  prettyCandidates = prettyCandidates.sort {|x,y| x[1].downcase <=> y[1].downcase }\n  if prettyCandidates.size > 1\n    #index = start\n    #test = false\n    #while !test\n    #  candidates.each_cons(2) do |a,b|\n    #    break if test = (a[index].chr != b[index].chr || a[index].chr == \"\\t\")\n    #  end\n    #  break if test\n    #  searchTerm << candidates[0][index].chr\n    #  index +=1\n    #end\n    \n    show_dialog(prettyCandidates,start) do |c,s|\n\t\t\tsnippet_generator(c,s, call)\n\t\tend\n  else\n    snippet_generator( candidates[0], start, call )\n  end\nend\n\ndef show_dialog(prettyCandidates,start,&snip_gen)\n    require \"#{ENV['TM_SUPPORT_PATH']}/lib/osx/plist\"\n    pl = {'menuItems' => prettyCandidates.map { |pretty,junk, full | { 'title' => pretty, 'cand' => full} }}\n    io = open('|\"$DIALOG\" -u', \"r+\")\n    io <<  pl.to_plist\n    io.close_write\n    res = OSX::PropertyList::load(io.read)\n    if res.has_key? 'selectedMenuItem'\n      snip_gen.call( res['selectedMenuItem']['cand'], start )\n    else\n      \"$0\"\n    end\nend\n\ndef candidates_or_exit(methodSearch, list, fileNames, notif = false)\n\tx = candidate_list(methodSearch, list, fileNames, notif)\n  TextMate.exit_show_tool_tip \"No completion available\" if x.empty?\n  return x\nend\n\ndef candidate_list(methodSearch, list, fileNames, notif = false)\n  candidates = []\n  fileNames.each do |fileName|\n    zGrepped = %x{ zgrep ^#{e_sh methodSearch } #{e_sh ENV['TM_BUNDLE_SUPPORT']}/#{fileName} }\n    candidates += zGrepped.split(\"\\n\")\n  end\n  # strip notifications\n  if notif\n\t  candidates = candidates.select {|cand| cand.match(/\\tno\\t/) }\n\telse\n    candidates = candidates.reject {|cand| cand.match(/\\tno\\t/) }\n  end\n  return [] if candidates.empty?\n  if list.nil?\n    return candidates\n  else\n    n = []\n    candidates.each do |cand|\n      n << cand if list.include?(cand.split(\"\\t\")[0])\n    end\n    n = (n.empty? ? candidates : n)\n\n    return n\n  end\nend\n\nmethodDeclaration = /^((?:\\+|-)\\s*)([a-zA-Z][a-zA-Z0-9:]*)$/\n\nif k = line.match(methodDeclaration)\n  candidates = candidates_or_exit( k[2], nil, \"cocoa.txt.gz\")\n  res =pop_up(candidates, k[2])\n  TextMate.exit_discard if res == \"$0\"\n  print k[1] + res\nelse\n  TextMate.exit_discard\nend\n",
  "fallbackInput": "line",
  "input": "selection",
  "keyEquivalent": "~\u001b",
  "name": "Completion: Partial Method Signature",
  "output": "insertAsSnippet",
  "scope": "meta.function.objc - (meta.argument-type.objc | meta.return-type.objc | meta.bracketed)"
}
