{
  "beforeRunningCommand": "nop",
  "bundleUUID": "4679484F-6227-11D9-BFB1-000D93589AF6",
  "command": "#!/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby\nrequire \"#{ENV['TM_SUPPORT_PATH']}/lib/escape\"\nrequire ENV['TM_SUPPORT_PATH'] + \"/lib/exit_codes\"\n\nclass Lexer\n  include Enumerable\n  def initialize\n    @label   = nil\n    @pattern = nil\n    @handler = nil\n    @input   = nil\n    \n    reset\n    \n    yield self if block_given?\n  end\n  \n  def input(&reader)\n    if @input.is_a? self.class\n      @input.input(&reader)\n    else\n      class << reader\n        alias_method :next, :call\n      end\n      \n      @input = reader\n    end\n  end\n  \n  def add_token(label, pattern, &handler)\n    unless @label.nil?\n      @input = clone\n    end\n    \n    @label   = label\n    @pattern = /(#{pattern})/\n    @handler = handler || lambda { |label, match| [label, match] }\n    \n    reset\n  end\n  \n  def next(peek = false)\n    while @tokens.empty? and not @finished\n      new_input = @input.next\n      if new_input.nil? or new_input.is_a? String\n        @buffer    += new_input unless new_input.nil?\n        new_tokens =  @buffer.split(@pattern)\n        while new_tokens.size > 2 or (new_input.nil? and not new_tokens.empty?)\n          @tokens << new_tokens.shift\n          @tokens << @handler[@label, new_tokens.shift] unless new_tokens.empty?\n        end\n        @buffer   = new_tokens.join\n        @finished = true if new_input.nil?\n      else\n        separator, new_token = @buffer.split(@pattern)\n        new_token            = @handler[@label, new_token] unless new_token.nil?\n        @tokens.push( *[ separator,\n                         new_token,\n                         new_input ].select { |t| not t.nil? and t != \"\" } )\n        reset(:buffer)\n      end\n    end\n    peek ? @tokens.first : @tokens.shift\n  end\n  \n  def peek\n    self.next(true)\n  end\n  \n  def each\n    while token = self.next\n      yield token\n    end\n  end\n  \n  private\n  \n  def reset(*attrs)\n    @buffer   = String.new if attrs.empty? or attrs.include? :buffer\n    @tokens   = Array.new  if attrs.empty? or attrs.include? :tokens\n    @finished = false      if attrs.empty? or attrs.include? :finished\n  end\nend\n\n\nclass ObjcParser\n\t\n\tattr_reader :list\n  def initialize(args)\n    @list = args\n  end\n  \n  def get_position\n    return nil,nil if @list.empty?\n\thas_message = true\n\n    a = @list.pop\n    endings = [:close,:post_op,:at_string,:at_selector,:identifier]\nopenings = [:open,:return,:control]\n    if a.tt == :identifier && !@list.empty? && endings.include?(@list[-1].tt)\n      insert_point = find_object_start\n    else\n      @list << a\n\thas_message = false unless methodList\n      insert_point = find_object_start\n    end\nreturn insert_point, has_message\n  end\n  \n  def methodList\n    \told = Array.new(@list)\n\n    a = selector_loop(@list)\n    if !a.nil? && a.tt == :selector\n      if file_contains_selector? a.text\n        return true\n      else\n        internal = Array.new(@list)\n        b = a.text\n        until internal.empty?\n          tmp = selector_loop(internal)\n          return true if tmp.nil?\n          b = tmp.text + b\n          if file_contains_selector? b\n            @list = internal\n            return true\n          end\n        end\n      end\n\telse\n    end\n@list = old\nreturn false\n  end\n  \n  def file_contains_selector?(methodName)\n    fileNames = [\"#{ENV['TM_BUNDLE_SUPPORT']}/cocoa.txt.gz\"]\n    userMethods = \"#{ENV['TM_PROJECT_DIRECTORY']}/.methods.TM_Completions.txt.gz\"\n\n    fileNames += [userMethods] if File.exists? userMethods\n    candidates = []\n    fileNames.each do |fileName|\n      zGrepped = %x{zgrep ^#{e_sh methodName }[[:space:]] #{e_sh fileName }}\n      candidates += zGrepped.split(\"\\n\")\n    end\n\n    return !candidates.empty?\n  end\n  \n  def selector_loop(l)\n    until l.empty?\n      obj = l.pop\n      case obj.tt\n      when :selector\n        return obj\n      when :close\n        return nil if match_bracket(obj.text,l).nil?\n      when :open\n        return nil\n      end\n    end\n    return nil\n  end\n  \n  def match_bracket(type,l)\n    partner = {\"]\"=>\"[\",\")\"=>\"(\",\"}\"=>\"{\"}[type]\n    up = 1\n    until l.empty?\n      obj = l.pop\n      case obj.text\n      when type\n        up +=1\n      when partner\n        up -=1\n      end\n      return obj.beg if up == 0\n    end\n  end\n  \n  def find_object_start\n    openings = [:operator,:selector,:open,:return,:control]\n    until @list.empty? || openings.include?(@list[-1].tt)\n      obj = @list.pop\n      case obj.tt\n      when :close\n        tmp = match_bracket(obj.text, @list)\n        b = tmp unless tmp.nil?\n      when :star\n        b, ate = eat_star(b,obj.beg)\n        return b unless ate\n      when :nil\n        b = nil\n      else\n        b = obj.beg\n      end\n    end\n    return b\n  end\n\n  def eat_star(prev, curr)\n    openings = [:operator,:selector,:open,:return,:control,:star]\n    if @list.empty? || openings.include?(@list[-1].tt)\n      return curr, true\n    else\n      return prev, false\n    end\n  end\nend\n\nif __FILE__ == $PROGRAM_NAME\n  require \"stringio\"\n  line = ENV['TM_CURRENT_LINE']\n  caret_placement =ENV['TM_LINE_INDEX'].to_i - 1\n\n  up = 0\n  pat = /\"(?:\\\\.|[^\"\\\\])*\"|\\[|\\]/\n    line.scan(pat).each do |item|\n       case item\n       when \"[\"\n         up+=1\n       when \"]\"\n         up -=1\n       end\n     end\n  if caret_placement ==-1\n    print \"]$0\" + e_sn(line[caret_placement+1..-1])\n    TextMate.exit_insert_snippet\n  end\n\n  if  up != 0 \n    print e_sn(line[0..caret_placement])+\"]$0\"+e_sn(line[caret_placement+1..-1])\n    TextMate.exit_insert_snippet\n  end\n  \n  to_parse = StringIO.new(line[0..caret_placement])\n  lexer = Lexer.new do |l|\n    l.add_token(:return,  /\\breturn\\b/)\n    l.add_token(:nil, /\\bnil\\b/)\n    l.add_token(:control, /\\b(?:if|while|for|do)(?:\\s*)\\(/)# /\\bif|while|for|do(?:\\s*)\\(/)\n    l.add_token(:at_string, /\"(?:\\\\.|[^\"\\\\])*\"/)\n    l.add_token(:selector, /\\b[A-Za-z_0-9]+:/)\n    l.add_token(:identifier, /\\b[A-Za-z_0-9]+\\b/)\n    l.add_token(:bind, /(?:->)|\\./)\n    l.add_token(:post_op, /\\+\\+|\\-\\-/)\n    l.add_token(:at, /@/)\n    l.add_token(:star, /\\*/)\n    l.add_token(:close, /\\)|\\]|\\}/)\n    l.add_token(:open, /\\(|\\[|\\{/)\n    l.add_token(:operator,   /[&-+\\/=%!:\\,\\?;<>\\|\\~\\^]/)\n\n    l.add_token(:terminator, /;\\n*|\\n+/)\n    l.add_token(:whitespace, /\\s+/)\n    l.add_token(:unknown,    /./) \n    \n    l.input { to_parse.gets }\n    #l.input {STDIN.read}\n  end\n\n  offset = 0\n  tokenList = []\n  A = Struct.new(:tt, :text, :beg)\n\n  lexer.each do |token| \n    tokenList << A.new(*(token<<offset)) unless [:whitespace,:terminator].include? token[0]\n    offset +=token[1].length\n  end\n  if tokenList.empty?\n    print e_sn(line[0..caret_placement])+\"]$0\"+e_sn(line[caret_placement+1..-1])\n    TextMate.exit_insert_snippet\n  end\n  \n  par = ObjcParser.new(tokenList)\n  b, has_message = par.get_position\n\n  if !line[caret_placement+1].nil? && line[caret_placement+1].chr == \"]\"\n    if b.nil? || par.list.empty? || par.list[-1].text == \"[\"\n\t\t\tprint e_sn(line[0..caret_placement])+\"]$0\"+e_sn(line[caret_placement+2..-1])\n    \tTextMate.exit_insert_snippet\n\t\tend\n  end\n\n  if b.nil?\n    print e_sn(line[0..caret_placement])+\"]$0\"+e_sn(line[caret_placement+1..-1])\n  elsif !has_message && (b < caret_placement )\n    print e_sn(line[0..b-1]) unless b == 0\n    ins = (/\\s/ =~ line[caret_placement].chr ? \"$0]\" : \" $0]\")\n    print \"[\" +e_sn(line[b..caret_placement]) + ins +e_sn(line[caret_placement+1..-1])\n  elsif b < caret_placement    \n    print e_sn(line[0..b-1]) unless b == 0\n    print \"[\" +e_sn(line[b..caret_placement]) +\"]$0\"+e_sn(line[caret_placement+1..-1]) \n  else\n    print e_sn(line[0..caret_placement])+\"]$0\"+e_sn(line[caret_placement+1..-1])\n  end\nend\n",
  "fallbackInput": "line",
  "input": "selection",
  "keyEquivalent": "]",
  "name": "Insert Matching Start Bracket",
  "output": "insertAsSnippet",
  "scope": "(source.objc | source.objc++) - (string | comment | dyn.selection | dyn.caret.mixed)"
}
