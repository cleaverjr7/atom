{
  "beforeRunningCommand": "nop",
  "bundleUUID": "4679484F-6227-11D9-BFB1-000D93589AF6",
  "command": ". \"$TM_SUPPORT_PATH/lib/webpreview.sh\"\nhtml_header \"Objective-C Bundle Help\" \"Objective-C\"\n\"$TM_SUPPORT_PATH/lib/markdown_to_help.rb\" <<'MARKDOWN'\n\n# Introduction\n\nThis document describes the commands of the Objective-C bundle and is a recommended read, since not all features are easy to discover.\n\nIn addition to this help file there are also 3 screencasts dedicated to showing Objective-C features (the links below are to more info about the screencast):\n\n 1. The [most recent][SC1] is by Joachim Mårtensson and shows completion, bracket matching, reformatting methods, and documentation lookup.\n 2. [Objective-C Part 2][SC2] by Allan Odgaard.\n 3. [Graceful Objective-C Snippets][SC3] by Allan Odgaard.\n\nYou can see [all screencasts here][AllCasts].\n\n[SC1]: http://macromates.com/screencast/TextMateObjCScreenCast.mov\n[SC2]: http://macromates.com/blog/archives/2006/04/29/objective-c-part-2-screencast/\n[SC3]: http://macromates.com/blog/archives/2006/03/17/graceful-objective-c-snippets/\n[AllCasts]: http://macromates.com/screencasts\n\n# Code Completion\n\nCode Completion is activated using the ⌥⎋ key equivalent. Code completion is available in several places which will be the topic of the next few sections.\n\n## Within Brackets\n\nA method call in Objective-C consists of three different types (though not all method calls take arguments):\n\n\t[«receiver» «selector»:«argument»]\n\nThe completion support can help you with all three parts, which will be explained in the following three sections.\n\n### Receiver\n\nA partially typed receiver can be completed, here candidates are all Cocoa classes (class objects). For example if we have:\n\n\t[NSObje‸ ]\n\nThen the list of possible completions will contain `NSObject` and `NSObjectController`.\n\n### Selector\n\nWhen the receiver is a class object, like in the following example:\n\n\t[NSString ‸]\n\nThen the candidates are all methods implemented by that class, in the above example, that would be all `NSString` class methods.\n\nIf the selector is partially typed, and the receiver is not a known class object, as is the case below:\n\n\t[object setV‸]\n\nThen a list is shown with all Cocoa methods starting with `setV`.\n\nCurrently the list of completion candidates are only filtered to those implemented by `object`, when object is a method local variable of a type that has been indexed.\n\nOne exception is when the receiver is itself a method call, for example in the following case:\n\n\t[[object string] ‸]\n\nHere only methods implemented by `NSString` are suggested, since it is know that the result of the `string` selector is an `NSString` object.\n\nFor selectors with multiple arguments, it is possible to activate completion when entering the name of a later argument, for example:\n\n\t[object setObject:name forK‸]\n\nWill list all methods starting with `setObject:forK`.\n\n### Argument\n\nWhen at the argument position, like here:\n\n    [NSString stringWithCString:\"foo\" encoding:‸]\n\nThe completion command will check the argument type and find all constants which match that type. In the above example that would be all string encoding constants.\n\n## Outside of Brackets\n\nThe completion command will give different suggestions based on the caret’s scope. To see the current scope you can press ⌃⇧P. The 6 different scopes are marked below:\n\n\t@interface MyClass : NSO‸₁ <NSObj‸₂>\n\t{\n\t\tNSSt‸₃\n\t}\n\t@end\n\t\n\t@implementation MyClass\n\t- (id)init\n\t{\n\t\tif(self = [super init])\n\t\t{\n\t\t\tNSArr‸₄\n\t\t}\n\t\treturn self;\n\t}\n\t- windowW‸₅\n\t- (NSStr‸₆)stringFromString(NSSt‸₆<NSCod‸₂>)\n\t@end\n\nThe candidates suggested for the 6 different scopes are:\n\n 1. Known Cocoa classes.\n 2. Known Cocoa protocols.\n 3. Same as 1, but a variable name will also be inserted. For example the above will suggest `NSString` and `NSStream`. If we pick the former, it will insert `NSString *aString`.\n 4. Same as 3, but completion of known (C, C++, and Cocoa) functions is also suggested.\n 5. Here completion candidates are known Cocoa methods, but inserted as when implementing the method. For example in the above, one of the suggestions is `windowWillClose`, which when selected, will have the line changed to: `- (void)windowWillClose:(NSNotification *)aNotification`.\n 6. Same as 1, but an asterisk (`*`) is inserted.\n\n## Completing User Methods\n\nBy default completion candidates comes from the various Apple frameworks (mostly under the Cocoa umbrella).\n\nIf you wish to have your own methods and classes shown as completion candidates, you can invoke the *Index Headers for Completion* command.\n\nThis scans all headers in the current project folder and saves the result as `.methods.TM_Completions.txt.gz` and `.classes.TM_Completions.txt.gz` in your project folder.\n\nYou can later re-run the command to update the index.\n\n# Bracket Matching\n\n## Wrapping Selectors\n\nWhen you want to send a message (selector) to an object, you need to wrap both the object and message in square brackets (`[object message]`). Even if you did not put an opening bracket at the start of the expression, there is no need to go back and place it, since TextMate is smart enough to figure out where to place the start bracket, when typing an unmatched close bracket.\n\nHere are two simple examples:\n\n    obj message‸     → [obj message]\n    \n    obj message:arg‸ → [obj message:arg]\n\nAn ambiguity exists when sending multi-argument messages to the object. For example if we have:\n\n    obj message:arg otherMessage:arg2‸\n\nThen there are two candidates for the outcome:\n\n    1. [obj message:arg otherMessage:arg2]\n    2. obj message:[arg otherMessage:arg2]\n\nIf `message:otherMessage:` is a known Cocoa method or one of your indexed methods, then the first one is picked, otherwise the second one.\n\n## Wrapping Objects\n\nIf you type a closing bracket after a single word, it is assumed that this word is an object to which you want to send a message, e.g.:\n\n    obj‸ → [obj ‸]\n\nThe space is only inserted if there is not already a space after the object.\n\n## General\n\nThe bracket completion is aware of quite a few C and Objective-C constructs and will not wrap when it does not make (much) sense.\n\n\tnil‸         → nil] // no messaging nil\n\treturn self‸ → return [self ‸]\n\tNSArray arrayWithObjects:names, urls, nil‸\n\t             → [NSArray arrayWithObjects:names, urls, nil]\n\nHere is how the bracket matcher (basically) works:\n\n 1. If there is a word to the left of the caret, try to find an object to the left of it.\n 2. If the above failed, look for a message that takes an argument. If found, try to find even more such messages compare them with known Cocoa methods as we go, if no known Cocoa methods are found we use only the first matched message. try to find an object to the left of the message.\n 3. If neither 1 or 2, we have a single object, wrap it and insert the caret between the brackets.\n    \n# Reformatting\n\n## Method Calls\n\nPressing ⌃Q when the caret is inside a multi-part method call will align the method-parts around the colon (`:`). For example the following:\n\n\t[NSEvent enterExitEventWithType:anEventType location:aPoint\n\t\tmodifierFlags:flags timestamp:aTimeInterval\n\t\twindowNumber:number context:aGraphicsContext\n\t\teventNumber:x trackingNumber:tracker userData:data]\n\nWill be reformatted as:\n\n\t[NSEvent enterExitEventWithType:anEventType\n\t                       location:aPoint\n\t                  modifierFlags:flags\n\t                      timestamp:aTimeInterval\n\t                   windowNumber:number\n\t                        context:aGraphicsContext\n\t                    eventNumber:x\n\t                 trackingNumber:tracker\n\t                       userData:data]\n\nBy default the inner brackets will be reformatted if the brackets are nested, move the caret to a non nested area to get the outer methods reformatted.\n\n## Method Implementations\n\nLike with method calls, we can reformat method implementations using ⌃Q. If for example we implemented the method above, and our source looks like this:\n\n\t+ (NSEvent *)enterExitEventWithType:(NSEventType)type\n\tlocation:(NSPoint)location modifierFlags:(unsigned int)flags\n\ttimestamp:(NSTimeInterval)time windowNumber:(int)windowNumber\n\tcontext:(NSGraphicsContext *)context eventNumber:(int)eventNumber\n\ttrackingNumber:(int)trackingNumber userData:(void *)userData\n\t{\n\t\n\t}\n\nThen we can reformat it easily using ⌃Q on the first line, and we get:\n\n\t+ (NSEvent *)enterExitEventWithType:(NSEventType)type\n\t                           location:(NSPoint)location\n\t                      modifierFlags:(unsigned int)flags\n\t                          timestamp:(NSTimeInterval)time\n\t                       windowNumber:(int)windowNumber\n\t                            context:(NSGraphicsContext *)context\n\t                        eventNumber:(int)eventNumber\n\t                     trackingNumber:(int)trackingNumber\n\t                           userData:(void*)userData\n\t{\n\t\n\t}\n\n# Documentation Look-up\n\nPressing ⌃H when the caret is on a class name, method call, function name, constant, or similar, will (for most known Cocoa stuff) find the appropriate spot in the documentation.\n\nThere are actually two documentation look-up commands (for two different scopes), so generally use the ⌃H key equivalent rather than the menu item.\n\n# Snippets\n\nThe Objective-C bundle has specialized several of the snippets for different scopes.\n\nAn example is shown below:\n\n\t@interface MyClass : NSObject\n\t{\n\t}\n\tm‸\n\t@end\n\t\n\t@implementation MyClass\n\tm‸\n\t\n\t- (void)myMethod\n\t{\n\t\tlog‸\n\t}\n\t@end\n\t\n\tvoid MyFunction ()\n\t{\n\t\tlog‸\n\t}\n\nHere we have entered both the tab trigger `m` and `log` in two different scopes. If we press tab (⇥) to expand all four tab triggers, then the resulting code becomes:\n\n\t@interface MyClass : NSObject\n\t{\n\t}\n\t- (id‸)method:(id)anArgument;\n\t@end\n\t\n\t@implementation MyClass\n\t- (id‸)method:(id)anArgument\n\t{\n\t\treturn nil;\n\t}\n\t\n\t- (void)myMethod\n\t{\n\t\tNSLog(@\"%s‸\", _cmd);\n\t}\n\t@end\n\t\n\tvoid MyFunction ()\n\t{\n\t\tNSLog(@\"‸\");\n\t}\n\nWhat’s interesting here is that the `m` tab trigger expands to a full method implementation inside `@implementation…@end`, but only a prototype when inside `@interface…@end`. Likewise the `log` tab trigger will only output the `_cmd` variable when called from inside a method (where it is available).\n\nAll the accessor snippets are likewise specialized for `@implementation` and `@interface`, though only one set appears in the menu (so use the tab trigger to get the proper one).\n\nIn addition to specializing the snippets for different scopes, a lot of other magic has also been put into them. If for example you add `%d` to the format string of the `NSLog` snippet, then an argument placeholder is automatically inserted. The method snippet will remove the `return nil;` line if you change the return type to `void`, and it will let the argument variable’s name match its type, for example if you change the type from `id` to `NSString*` then the variable becomes `aString`.\n\n# Credits\n\nThe cool stuff in this bundle is done by Joachim Mårtensson.\n\nAdditional work by Chris Thomas and Allan Odgaard. The initial bracket matcher (which served us well for a long time) was done by Rob Rix.\n\nMARKDOWN\nhtml_footer",
  "input": "none",
  "name": "Help",
  "output": "showAsHTML",
  "scope": "source.objc, source.objc++"
}
