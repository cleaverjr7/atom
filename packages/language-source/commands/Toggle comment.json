{
  "beforeRunningCommand": "nop",
  "command": "#!/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby\n\n# by James Edward Gray II <james (at) grayproductions.net>\n\n# \n# To override the operation of this commond for your language add a Preferences\n# bundle item that defines the following valiables as appropriate for your\n# language:\n# \n#   TM_COMMENT_START - the character string that starts comments, e.g. /*\n#   TM_COMMENT_END   - the character string that ends comments (if appropriate),\n#                      e.g. */\n#   TM_COMMENT_MODE  - the type of comment to use - either 'line' or 'block'\n# \n\nrequire \"#{ENV[\"TM_SUPPORT_PATH\"]}/lib/escape\"\n\ndef out(*args)\n  print( *args.map do |arg|\n    escaped = e_sn(arg)\n    $selected ? escaped.gsub(\"}\", \"\\\\}\") : escaped.sub(\"\\0\", \"${0}\")\n  end )\nend\n\n# find all available comment variables\nvar_suffixes = [\"\"]\n2.upto(1.0/0.0) do |n|\n  if ENV.include? \"TM_COMMENT_START_#{n}\"\n    var_suffixes << \"_#{n}\"\n  else\n    break\n  end\nend\n\ntext    = STDIN.read\ndefault = nil  # the comment we will insert, if none are removed\n\n# maintain selection\nif ENV.has_key?(\"TM_SELECTED_TEXT\")\n  $selected = true\n  print \"${0:\"\n  at_exit { print \"}\" }\nelse\n  $selected = false\nend\n\n# try a removal for each comment...\nvar_suffixes.each do |suffix|\n  # build comment\n  com = { :start     => ENV[\"TM_COMMENT_START#{suffix}\"] || \"# \",\n          :end       => ENV[\"TM_COMMENT_END#{suffix}\"]   || \"\",\n          :mode      => ENV[\"TM_COMMENT_MODE#{suffix}\"]  ||\n                        (ENV[\"TM_COMMENT_END#{suffix}\"] ? \"block\" : \"line\"),\n          :no_indent => ENV[\"TM_COMMENT_DISABLE_INDENT#{suffix}\"] }\n  \n  com[:esc_start], com[:esc_end] = [com[:start], com[:end]].map do |str|\n    str.gsub(/[\\\\|()\\[\\].?*+{}^$]/, '\\\\\\\\\\&').\n        gsub(/\\A\\s+|\\s+\\z/, '(?:\\&)?')\n  end\n  \n  # save the first one as our insertion default\n  default = com if default.nil?\n  \n  # try a removal\n  case com[:mode]\n  when \"line\"  # line by line comment\n    if text !~ /\\A[\\t ]+\\z/ &&\n       text.send(text.respond_to?(:lines) ? :lines : :to_s).\n            map { |l| !!(l =~ /\\A\\s*(#{com[:esc_start]}|$)/) }.uniq == [true]\n      if $selected\n        out text.gsub( /^(\\s*)#{com[:esc_start]}(.*?)#{com[:esc_end]}(\\s*)$/,\n                       '\\1\\2\\3' )\n        exit\n      else\n        r = text.sub( /^(\\s*)#{com[:esc_start]}(.*?)#{com[:esc_end]}(\\s*)$/,\n                      '\\1\\2\\3' )\n        i = ENV[\"TM_LINE_INDEX\"].to_i\n        i = i > text.index(/#{com[:esc_start]}/)            ?\n            [[0, i - com[:start].length].max, r.length].min :\n            [i, r.length].min\n        r[i, 0] = \"\\0\"\n        out r\n        exit\n      end\n    end\n  when \"block\" # block comment\n    regex = /\\A(\\s*)#{com[:esc_start]}(.*?)#{com[:esc_end]}(\\s*)\\z/m\n    if text =~ regex\n      if $selected\n        out text.sub(regex, '\\1\\2\\3')\n        exit\n      else\n        r = text.sub(regex, '\\1\\2\\3')\n        i = ENV[\"TM_LINE_INDEX\"].to_i\n        i = i > text.index(/#{com[:esc_start]}/)            ?\n            [[0, i - com[:start].length].max, r.length].min :\n            [i, r.length].min\n        r[i, 0] = \"\\0\"\n        out r\n        exit\n      end\n    end\n  end\nend\n\n# none of our removals worked, so preform an insert (minding indent setting)\ntext[ENV[\"TM_LINE_INDEX\"].to_i, 0] = \"\\0\" unless $selected or text.empty?\ncase default[:mode]\nwhen \"line\"  # apply comment line by line\n  if text.empty?\n    out \"#{default[:start]}\\0#{default[:end]}\"\n  elsif default[:no_indent]\n    out text.gsub(/^.*$/, \"#{default[:start]}\\\\&#{default[:end]}\")\n  elsif text =~ /\\A([\\t ]*)\\0([\\t ]*)\\z/\n    out text.gsub(/^.*$/, \"#{$1}#{default[:start]}#{$2}#{default[:end]}\")\n  else\n    indent = text.scan(/^[\\t \\0]*(?=\\S)/).\n                  min { |a, b| a.length <=> b.length } || \"\"\n    text.send(text.respond_to?(:lines) ? :lines : :to_s).map do |line|\n      if line =~ /^(#{indent})(.*)$(\\n?)/ then\n        out $1 + default[:start] + $2 + default[:end] + $3\n      elsif line =~ /^(.*)$(\\n?)/ then\n        out indent + default[:start] + $1 + default[:end] + $2\n      end\n    end\n  end\nwhen \"block\" # apply comment around selection\n  if text.empty?\n    out default[:start]\n    print \"${0}\"\n    out default[:end]\n  elsif text =~ /\\A([\\t ]*)\\0([\\t ]*)\\z/\n    out $1, default[:start]\n    print \"${0}\"\n    out $2, default[:end]\n  elsif default[:no_indent]\n    out default[:start], text, default[:end]\n  else\n    lines = text.to_a\n    if lines.empty?\n      out default[:start], default[:end]\n    else\n      lines[-1].sub!(/^(.*)$/, \"\\\\1#{default[:end]}\")\n      out lines.shift.sub(/^([\\s\\0]*)(.*)$/, \"\\\\1#{default[:start]}\\\\2\")\n      out(*lines) unless lines.empty?\n    end\n  end\nend\n",
  "disableOutputAutoIndent": true,
  "fallbackInput": "line",
  "input": "selection",
  "inputFormat": "text",
  "keyEquivalent": "@/",
  "name": "Comment Line / Selection",
  "outputCaret": "afterOutput",
  "outputFormat": "snippet",
  "outputLocation": "replaceInput",
  "version": 2
}
